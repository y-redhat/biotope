<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>NovaNotions â€“ Ideology Biotope (ä¿è­·å€‹ä½“: 2åˆ†ç”Ÿå­˜ä¿è¨¼)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<style>
body{margin:0;background:#000;font-family:monospace;overflow:hidden}
#ui{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);width:90%;text-align:center;z-index:10}
input{width:60%;padding:10px;background:rgba(0,0,0,.8);border:1px solid #0f0;color:#0f0}
#stats{color:#aaa;font-size:12px;margin-bottom:4px}
#log{position:absolute;top:10px;left:10px;width:420px;height:260px;overflow:auto;
font-size:11px;color:#0f0;background:rgba(0,0,0,.6);border:1px solid #033;padding:5px}
</style>
</head>

<body>
<div id="log"></div>
<div id="ui">
<div id="stats">
TIME:<span id="timer">00:00</span> |
YEAR:<span id="year">0</span> |
POP:<span id="pop">0</span> |
CIV:<span id="civ">Hunter-Gatherer</span> |
WAR:<span id="warstat">NO</span>
</div>
<input id="cmd" placeholder="> genesis / evolve / war / meteor / reset">
</div>

<script>
/* =====================
   ã‚°ãƒ­ãƒ¼ãƒãƒ«
===================== */
let organisms=[],foods=[],time=0,epoch=0;
let fertility=1,civilization=0,war=false;
const CIV_NAMES=["Hunter-Gatherer","Agriculture","Nation"];

const FOOD_TYPES={
 plant:{color:[100,255,100],energy:0.25},
 meat:{color:[255,80,80],energy:0.6},
 farm:{color:[180,255,120],energy:0.4}
};

/* å›½å®¶ç®¡ç† */
let nations = [];
let nextNationId = 1;

/* ç¨¼åƒæ™‚é–“åˆ¶å¾¡ */
let startTime=0;
const MIN_RUN_MS = 1000 * 60 * 5; // 5åˆ†

/* ä¿è­·å€‹ä½“ã®ç”Ÿå­˜ä¿è¨¼ï¼ˆmsï¼‰ */
const PROTECTED_MS = 1000 * 60 * 2; // ç´„2åˆ†

function setup(){
 createCanvas(windowWidth,windowHeight);
 spawnFood(200);

 startTime = millis();
 runCommand("genesis");

 // ã‚‚ã—å­˜åœ¨ã™ã‚Œã°æœ€åˆã®å€‹ä½“ã‚’ä¿è­·å€‹ä½“ã«ã™ã‚‹
 if(organisms.length>0){
  organisms[0].protectedUntil = millis() + PROTECTED_MS;
  log("ğŸ”° Protected individual set for ~2 minutes");
 }

 cmd.addEventListener("keydown",e=>{
  if(e.key==="Enter"){runCommand(cmd.value);cmd.value="";}
 });
}

/* =====================
   ãƒ¡ã‚¤ãƒ³
===================== */
function draw(){
 time++; if(time%60===0) epoch++;
 background(0,30*fertility,10);

 // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºï¼ˆmm:ssï¼‰
 let elapsed = millis() - startTime;
 let s = floor(elapsed/1000);
 let mm = nf(floor(s/60),2);
 let ss = nf(s%60,2);
 timer.innerText = mm + ":" + ss;

 // æ–‡æ˜é€²åŒ–
 if(organisms.length>40 && civilization===0) civilization=1;
 if(organisms.length>120 && civilization===1) civilization=2;

 // UI
 year.innerText=epoch;
 pop.innerText=organisms.length;
 civ.innerText=CIV_NAMES[civilization];
 warstat.innerText=war?"YES":"NO";

 // é£Ÿæ–™ç”Ÿæˆï¼ˆæ–‡æ˜ã§ farm å‡ºç¾ç¢ºç‡å¤‰åŒ–ï¼‰
 if(random()<0.12*fertility){
  let type="plant";
  if(civilization>=1 && random()<0.3) type="farm";
  foods.push({pos:createVector(random(width),random(height)),type});
 }

 // é£Ÿæ–™æç”»
 noStroke();
 for(let f of foods){
  let c=FOOD_TYPES[f.type].color;
  fill(c[0],c[1],c[2],140);
  circle(f.pos.x,f.pos.y,4);
 }

 // å€‹ä½“æ›´æ–°
 let red=0,blue=0;
 for(let i=organisms.length-1;i>=0;i--){
  let o=organisms[i];
  o.update();
  o.show();
  if(o.dead()){
   // ä¿è­·å€‹ä½“ã¯ dead() ãŒ false ã‚’è¿”ã™æœŸé–“ä¸­ã¯ã“ã“ã‚’é€šã‚‰ãªã„
   if(random()<0.5) foods.push({pos:o.pos.copy(),type:"meat"});
   if(o.nationId){
    let n = nations.find(x=>x.id===o.nationId);
    if(n) n.members = n.members.filter(m=>m!==o);
   }
   organisms.splice(i,1);
   fertility=min(1,fertility+0.001);
  }else{
   if(o.ideology==="red") red++; else blue++;
  }
 }

 // æœ€ä½5åˆ†é–“ã¯çµ¶æ»…ã‚’é˜²ãï¼ˆ5åˆ†æœªæº€ãªã‚‰å°‘æ•°è£œå……ï¼‰
 if(elapsed < MIN_RUN_MS){
  ensureMinPopulation(8);
 }

 // æˆ¦äº‰æ¡ä»¶ï¼ˆè‡ªå‹•ç™ºç”Ÿã¯5åˆ†å¾Œã‹ã‚‰ï¼‰
 if(!war && organisms.length>100 && elapsed>=MIN_RUN_MS) startWar();
 if(!war && organisms.length>100 && elapsed<MIN_RUN_MS){
  if(time % 300 === 0) log("War locked until 5 minutes have passed");
 }
 if(war){
  if(red<=10 && blue>10) endWar("red");
  if(blue<=10 && red>10) endWar("blue");
 }

 // å›½å®¶å½¢æˆã¯å®šæœŸçš„ã«ãƒã‚§ãƒƒã‚¯
 if(time % 600 === 0) formNations();

 // å›½å®¶ã”ã¨ã®å®šæœŸå‡¦ç†ï¼ˆè¾²å ´å»ºè¨­ãƒ»æ­³å…¥åé›†ï¼‰
 if(time % 180 === 0) nations.forEach(n=>nTick(n));
}

/* =====================
   ã‚³ãƒãƒ³ãƒ‰
===================== */
function runCommand(cmd){
 cmd=cmd.toLowerCase().trim();
 let elapsed = millis()-startTime;
 if(cmd==="genesis"){
  for(let i=0;i<10;i++){
   organisms.push(new Organism(random(width),random(height)));
  }
  // genesis å¾Œã«ä¿è­·å€‹ä½“ãŒæœªè¨­å®šãªã‚‰è¨­å®š
  if(!organisms[0].protectedUntil) organisms[0].protectedUntil = millis() + PROTECTED_MS;
  log("> genesis");
 }
 else if(cmd==="evolve"){
  organisms.forEach(o=>{
   o.dna.speed=constrain(o.dna.speed+random(-0.3,0.3),0.4,3);
  });
  log("> evolve");
 }
 else if(cmd==="meteor"){
  if(elapsed < MIN_RUN_MS){
   log("â˜„ METEOR LOCKED: simulation protected for 5 minutes");
   return;
  }
  organisms=organisms.slice(0,floor(organisms.length/2));
  fertility=0.2;
  log("â˜„ METEOR IMPACT");
 }
 else if(cmd==="war"){
  if(elapsed < MIN_RUN_MS){
   log("âš  War command locked until 5 minutes have passed");
   return;
  }
  startWar();
 }
 else if(cmd==="reset") location.reload();
}

/* =====================
   ç”Ÿç‰©
   ã™ã¹ã¦ red ã¾ãŸã¯ blue ã®ã¿ã€‚æ€æƒ³ã®å¼·ã•ã¯å½©åº¦(ã‚µãƒãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)ã§è¡¨ç¾ã€‚
===================== */
class Organism{
 constructor(x,y,dna){
  this.pos=createVector(x,y);
  this.vel=p5.Vector.random2D().mult(0.5);
  this.acc=createVector();

  // Ideology: red or blue only
  this.ideology = random()<0.5 ? "red" : "blue";
  if(this.ideology==="red") this.pos.x = random(width*0.05, width*0.45);
  else this.pos.x = random(width*0.55, width*0.95);

  // æ€æƒ³ã®å¼·ã•ï¼ˆ0.3ã€œ1.0ï¼‰ -> å½©åº¦ã«åæ˜ ï¼ˆæ¿ƒæ·¡ï¼‰
  this.ideologyStrength = random(0.35,1.0);

  // Hue å›ºå®š: red=0, blue=220
  this.baseHue = (this.ideology==="red") ? 0 : 220;

  this.dna=dna||{
   size:random(8,15),
   speed:random(0.6,1.2),
   sense:random(60,110),
  };

  this.diet=random(["herbivore","carnivore","omnivore"]);
  this.memory={good:0,bad:0};

  this.health=1;
  this.age=0;
  // å¯¿å‘½ã‚’é•·ã‚ã«ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹ã§ã¯ãªãæ™‚é–“çš„ã«æ­»ãªãªã„ã‚ˆã†ä¿è­·å€‹ä½“ã‚’è¨­å®šï¼‰
  this.maxAge=random(4000,8000);

  // æ€§åˆ¥ã¨ç¹æ®–é–¢é€£
  this.sex = (random()<0.5) ? "M" : "F";
  this.matingCooldown = 0;
  this.pregnant = false;
  this.gestation = 0;
  this.gestationPeriod = floor(random(600,1200));

  // stash / coop / infection
  this.stash = 0;
  this.coopCooldown = 0;

  this.infected = false;
  this.virusLoad = 0;
  this.immunity = random(0.0,0.6);

  this.nationId = null;

  // ä¿è­·çµ‚äº†æ™‚åˆ»ï¼ˆmsï¼‰ã€‚æœªè¨­å®šãªã‚‰ undefined
  this.protectedUntil = this.protectedUntil || undefined;
 }

 update(){
  this.age++;
  if(this.health<=0||this.age>this.maxAge) this.health=0;

  // è‡ªç„¶æ¶ˆè€—ã¯æ§ãˆã‚
  this.health -= 0.0005 * pow(this.dna.size,0.6);

  // æ„ŸæŸ“ã®ã‚†ã£ãã‚Šã—ãŸå½±éŸ¿ï¼ˆè‡´æ­»æ€§æŠ‘åˆ¶ï¼‰
  if(this.infected){
   this.health -= this.virusLoad * 0.0007 * (1 - this.immunity*0.6);
   if(random() < 0.0009 + this.immunity*0.001) {
    this.virusLoad = max(0, this.virusLoad - 0.045);
    if(this.virusLoad < 0.05){ this.infected=false; this.virusLoad=0; log("âœš recovered"); }
   }
  }

  // å¦Šå¨ ãƒ»äº¤å°¾ãƒ»æ¡é¤Œ
  if(this.pregnant){
   this.gestation++;
   if(this.gestation >= this.gestationPeriod) this.giveBirth();
  }else if(this.matingCooldown <= 0){
   if(this.health > 0.9 && random() < 0.002) {
    if(this.sex==="F") this.seekMate();
    else this.forage();
   }else this.forage();
  }else this.forage();

  // æ€æƒ³åˆ¥æŒ™å‹•
  if(this.ideology==="blue") this.vel.limit(this.dna.speed * (war?1.35:1.1));
  else this.vel.limit(this.dna.speed * (war?1.2:1.0));

  this.vel.add(this.acc);
  this.pos.add(this.vel);
  this.acc.mult(0);

  this.edges();

  // æˆ¦äº‰ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆblueã¯ã‚„ã‚„æ”»æ’ƒçš„ï¼‰
  if(war){
   for(let o of organisms){
    if(o!==this && o.ideology!==this.ideology && dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y)<6){
     let killProb = (this.ideology==="blue") ? 0.02 : 0.007;
     if(random()<killProb) o.health = max(0, o.health - random(0.5,1.0));
     if(this.ideology==="red") this.callForAid();
    }
   }
  }

  if(this.matingCooldown>0) this.matingCooldown--;
  if(this.coopCooldown>0) this.coopCooldown--;

  if(this.stash > 0) this.stash = max(0, this.stash - 0.00035);

  if(this.nationId){
   let n = nations.find(x=>x.id===this.nationId);
   if(n && this.ideology==="blue"){
    let tax = this.stash * 0.0008;
    n.treasury += tax;
    this.stash -= tax;
   }else if(n && this.ideology==="red"){
    n.treasury += 0.0002;
   }
  }

  // æ¥è§¦æ„ŸæŸ“ï¼ˆç·©ã‚„ã‹ï¼‰
  for(let o of organisms){
   if(o!==this && dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y) < 8){
    if(this.infected && !o.infected && random()<0.0008*this.virusLoad){
     o.infect(this.virusLoad * 0.6);
    }
    if(o.infected && !this.infected && random()<0.0008*o.virusLoad){
     this.infect(o.virusLoad * 0.6);
    }
   }
  }

  // ä¿è­·æœŸé–“ä¸­ã®å¼·åˆ¶ç¶­æŒ: protectedUntil ãŒç¾åœ¨ã‚ˆã‚Šå…ˆãªã‚‰æ­»äº¡ã‚’å¦¨ã’ã‚‹ãŸã‚æœ€ä½å¥åº·å€¤ã‚’ç¶­æŒ
  if(this.protectedUntil && millis() < this.protectedUntil){
   // æœ€ä½å¥åº·ã‚’ç¢ºä¿ã™ã‚‹ã“ï¿½ï¿½ï¿½ã§æ­»äº¡ã‚’é˜²ã
   this.health = max(this.health, 0.15);
   // ã‚¦ã‚¤ãƒ«ã‚¹ã§æ­»ãªãªã„ã‚ˆã†ã«ã‚¦ã‚¤ãƒ«ã‚¹è² è·ã‚’ç·©ã‚„ã‹ã«æŠ‘ãˆã‚‹
   if(this.infected) this.virusLoad = max(0, this.virusLoad - 0.02);
  }
 }

 // æ„ŸæŸ“
 infect(load){
  this.infected = true;
  this.virusLoad = constrain(this.virusLoad + load * random(0.6,1.0), 0, 1);
 }

 forage(){
  let nearest=null,dmin=this.dna.sense;
  for(let i=foods.length-1;i>=0;i--){
   let d=p5.Vector.dist(this.pos,foods[i].pos);
   let score = d;
   if(this.ideology==="blue" && foods[i].type==="farm") score *= 0.55;
   if(score<dmin){
    dmin=score; nearest=foods[i];
    if(dist(this.pos.x,this.pos.y,foods[i].pos.x,foods[i].pos.y) < this.dna.size){
     let gain = FOOD_TYPES[foods[i].type].energy;
     if(this.diet==="herbivore"&&foods[i].type==="meat") gain*=0.2;
     if(this.diet==="carnivore"&&foods[i].type!=="meat") gain*=0.2;

     if(this.ideology==="red"){
      let selfGain = gain * 0.82;
      let share = gain * 0.18;
      this.health += selfGain;
      this.memory.good++;
      if(this.coopCooldown===0){
       this.shareToAllies(share);
       this.coopCooldown = 240;
      }
     }else{
      let toStash = gain * 0.65;
      let selfGain = gain * 0.35;
      this.stash += toStash;
      this.health += selfGain;
      this.memory.good++;
     }

     if(random() < 0.0008) this.infect(0.12);

     foods.splice(i,1);
    }
   }
  }
  if(nearest) this.applyForce(this.seek(nearest.pos));
  else this.wander();
 }

 shareToAllies(amount){
  let given = 0;
  for(let o of organisms){
   if(o!==this && o.ideology==="red"){
    let d = dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y);
    if(d < 70 && o.health < 0.95){
     let take = min(amount*0.4, 0.25 - o.health);
     if(take>0){
      o.health += take;
      given += take;
     }
    }
   }
  }
  this.health = max(0, this.health - given*0.6);
  if(given>0) log("âœ¦ red redistributed energy");
 }

 callForAid(){
  for(let o of organisms){
   if(o!==this && o.ideology==="red"){
    let d = dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y);
    if(d < 80 && o.health < 0.6){
     o.health = min(1.3, o.health + 0.06);
    }
   }
  }
 }

 seekMate(){
  let nearestMale=null, dmin=this.dna.sense;
  for(let o of organisms){
   if(o !== this && o.ideology===this.ideology && o.sex==="M" && o.matingCooldown<=0){
    let d = dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y);
    if(d < dmin){
     dmin=d; nearestMale=o;
    }
   }
  }
  if(nearestMale){
   this.applyForce(this.seek(nearestMale.pos));
   if(dmin < this.dna.size*1.5){
    if(!this.pregnant && this.health>0.9 && nearestMale.health>0.8){
     this.becomePregnantBy(nearestMale);
     nearestMale.matingCooldown = 600;
     this.matingCooldown = 600;
    }
   }
  }else this.wander();
 }

 becomePregnantBy(male){
  if(this.sex!=="F" || this.pregnant) return;
  let success = random() < 0.9 * constrain((this.health + male.health)/2, 0.6, 1.2);
  if(success){
   this.pregnant = true;
   this.gestation = 0;
   this.gestationPeriod = floor(random(480,1200));
   log("â™¥ Pregnancy started ("+this.ideology+")");
  }else{
   log("â™¡ Mating failed");
  }
 }

 giveBirth(){
  this.pregnant = false;
  this.gestation = 0;
  let father = null;
  for(let o of organisms){
   if(o!==this && o.ideology===this.ideology && o.sex==="M"){
    if(dist(this.pos.x,this.pos.y,o.pos.x,o.pos.y) < 80){ father = o; break; }
   }
  }
  let childDNA = {
   size: this.dna.size + random(-1,1),
   speed: this.dna.speed + random(-0.2,0.2),
   sense: this.dna.sense + random(-8,8)
  };
  if(father){
   childDNA.size = (childDNA.size + father.dna.size)/2 + random(-0.7,0.7);
   childDNA.speed = (childDNA.speed + father.dna.speed)/2 + random(-0.2,0.2);
   childDNA.sense = (childDNA.sense + father.dna.sense)/2 + random(-6,6);
  }
  let child = new Organism(this.pos.x + random(-8,8), this.pos.y + random(-8,8), childDNA);
  if(father) child.ideologyStrength = (this.ideologyStrength + father.ideologyStrength)/2 + random(-0.05,0.06);
  else child.ideologyStrength = this.ideologyStrength;
  child.ideology = this.ideology;
  child.baseHue = (child.ideology==="red") ? 0 : 220;
  child.nationId = this.nationId;
  organisms.push(child);
  log("âœ³ Birth: new individual ("+this.ideology+")");
 }

 // dead(): ä¿è­·å€‹ä½“æœŸé–“ã¯æ­»äº¡æ‰±ã„ã«ã—ãªã„
 dead(){
  if(this.protectedUntil && millis() < this.protectedUntil) return false;
  return this.health<=0;
 }

 seek(t){
  let d=p5.Vector.sub(t,this.pos);
  d.setMag(this.dna.speed);
  return p5.Vector.sub(d,this.vel).limit(0.12);
 }

 applyForce(f){this.acc.add(f);}
 edges(){
  if(this.ideology==="red") this.pos.x=constrain(this.pos.x,0,width*0.55);
  else this.pos.x=constrain(this.pos.x,width*0.45,width);
  this.pos.y=constrain(this.pos.y,0,height);
 }
 show(){
  // è‰²ã¯æ€æƒ³ã”ã¨ã«å›ºå®šhueã€å¼·ã•ã‚’å½©åº¦ã«åæ˜ ï¼ˆæ¿ƒæ·¡ï¼‰
  colorMode(HSB,360,100,100,100);
  let sat = constrain(this.ideologyStrength * 100, 30, 100);
  fill(this.baseHue, sat, 90, 95);
  noStroke();
  ellipse(this.pos.x,this.pos.y,this.dna.size*0.8);

  if(this.pregnant){
   stroke(255,200,120);
   noFill();
   ellipse(this.pos.x,this.pos.y,this.dna.size*1.4);
   noStroke();
  }

  if(this.ideology==="blue" && this.stash>0.02){
   fill(200,80,90,80);
   circle(this.pos.x,this.pos.y - this.dna.size - 6, map(this.stash,0,2,2,8));
  }

  if(this.infected){
   fill(0,255,80,200);
   circle(this.pos.x + this.dna.size*0.45, this.pos.y - this.dna.size*0.45, 3);
  }

  colorMode(RGB,255);
 }
}

/* =====================
   å›½å®¶ï¼ˆç°¡æ˜“ï¼‰
===================== */
function formNations(){
 let unassigned = organisms.slice();
 let clusters = [];

 while(unassigned.length>0){
  let seed = unassigned.shift();
  let cluster = [seed];
  let changed = true;
  while(changed){
   changed=false;
   for(let i=unassigned.length-1;i>=0;i--){
    let o = unassigned[i];
    for(let c of cluster){
     if(o.ideology===c.ideology && dist(o.pos.x,o.pos.y,c.pos.x,c.pos.y) < 120){
      cluster.push(o);
      unassigned.splice(i,1);
      changed=true;
      break;
     }
    }
   }
  }
  clusters.push(cluster);
 }

 clusters.forEach(cluster=>{
  if(cluster.length >= 22){
   let anyMember = cluster[0];
   if(anyMember.nationId) return;
   let n = {
    id: nextNationId++,
    ideology: anyMember.ideology,
    members: cluster.slice(),
    treasury: 0,
    center: cluster.reduce((acc,o)=>{acc.x+=o.pos.x; acc.y+=o.pos.y; return acc;}, {x:0,y:0})
   };
   n.center.x /= cluster.length; n.center.y /= cluster.length;
   nations.push(n);
   cluster.forEach(o=> o.nationId = n.id);
   log("âš‘ Nation formed (id:"+n.id+", "+n.ideology+", pop:"+cluster.length+")");
  }
 });
}

function nTick(n){
 if(n.ideology==="red"){
  n.members.forEach(m=>{
   if(m && m.health < 0.95 && n.treasury > 0.01){
    m.health = min(1.4, m.health + 0.08);
    n.treasury = max(0, n.treasury - 0.01);
   }
  });
 }else{
  if(random() < 0.25){
   let cx = n.center.x + random(-80,80);
   let cy = n.center.y + random(-80,80);
   foods.push({pos:createVector(constrain(cx,0,width),constrain(cy,0,height)), type:"farm"});
   n.treasury = max(0, n.treasury - 0.02);
   log("ğŸ¦ Nation "+n.id+" built a farm");
  }
 }
 n.treasury += n.members.length * 0.0002;
 n.members = n.members.filter(m=>organisms.includes(m));
 if(n.members.length < 6){
  log("âœ– Nation "+n.id+" dissolved");
  n.members.forEach(m=>{ if(m) m.nationId = null; });
  nations = nations.filter(x=>x.id!==n.id);
 }
}

/* =====================
   æˆ¦äº‰
===================== */
function startWar(){
 if(civilization<2) {
  log("War cannot start until civilization reaches Nation");
  return;
 }
 war=true;
 log("âš” WAR STARTED");
}
function endWar(loser){
 war=false;
 log("ğŸ³ "+loser+" surrendered");
}

/* =====================
   è£œåŠ©
===================== */
function spawnFood(n){
 for(let i=0;i<n;i++)
  foods.push({pos:createVector(random(width),random(height)),type:"plant"});
}
function log(t){
 let l=document.getElementById("log");
 l.innerHTML=t+"<br>"+l.innerHTML;
}
function windowResized(){resizeCanvas(windowWidth,windowHeight);}

function ensureMinPopulation(minCount){
 if(organisms.length >= minCount) return;
 let need = minCount - organisms.length;
 for(let i=0;i<need;i++){
  let a = new Organism(random(width),random(height));
  a.ideology = (random()<0.5) ? "red" : "blue";
  a.baseHue = (a.ideology==="red") ? 0 : 220;
  organisms.push(a);
 }
 log("Population protected: spawned " + need + " individuals");
}
</script>
</body>
</html>
